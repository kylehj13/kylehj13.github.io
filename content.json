{"pages":[],"posts":[{"title":"Namespace","text":"네임스페이스는 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념입니다. 예를 들어 foo라는 이름의 함수를 만들어서 사용하다가 외부 라이브러리를 참조했을 때, 거기에도 foo라는 함수가 있다면 충돌이 발생합니다. 이럴 경우, 컴파일러는 foo가 어떤 함수를 가리키는지 알 수 없게 됩니다. 아래와 같은 간단한 예제 코드를 살펴봅시다. [namespace 예제 코드] 1234567891011121314151617181920#include &lt;iostream&gt;namespace nameA{ void foo(){ std::cout&lt;&lt;&quot;It is in nameA&quot;&lt;&lt;std::endl; }};namespace nameB{ void foo(){ std::cout&lt;&lt;&quot;It is in nameB&quot;&lt;&lt;std::endl; }};int main(void){ nameA::foo(); nameB::foo(); return 0;} [실행 결과] 12It is in nameAIt is in nameB 🎊 Scope Resolution Operator인 :: 기호를 이용해서 사용하면 됩니다. nested namespace라고 해서 namespace를 중첩해서 사용하는 것도 가능합니다. namespace alias로 이름을 다르게 표현할 수 있는데 아래 예제를 통해 두가지를 한번에 확인해봅시다. 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;namespace A{ namespace B{ namespace C{ void foo(){ std::cout&lt;&lt;&quot;Nested namespace example&quot;&lt;&lt;std::endl; } } }}namespace a::b::c{ void foo(){ std::cout&lt;&lt;&quot;Supported C++17&quot;&lt;&lt;std::endl; }}int main(void){ namespace ABC = A::B::C; namespace abc = a::b::c; A::B::C::foo(); a::b::c::foo(); ABC::foo(); abc::foo(); return 0;} 1234Nested namespace exampleSupported C++17Nested namespace exampleSupported C++17 🎊 만약 사용하는 빈도수가 높은 경우 using 이라는 지시자를 통해 컴파일러에 처리하도록 하면 됩니다. 보통 c++ 코드에서 쓰이는 using namespace std; 도 std라는 namespace를 :: 기호 없이 사용하겠다는 뜻으로 쓰인 구문입니다. [using 예제 코드] 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using std::cout;namespace nameA{ void foo(){ cout&lt;&lt;&quot;It is in nameA&quot;&lt;&lt;std::endl; }};namespace nameB{ void foo(){ cout&lt;&lt;&quot;It is in nameB&quot;&lt;&lt;std::endl; }};using namespace nameA;int main(void){ foo(); nameB::foo(); cout&lt;&lt;&quot;using std::cout (not endl)&quot;&lt;&lt; std::endl; return 0;} 123It is in nameAIt is in nameBusing std::cout (not endl) using namespace를 통해 nameA:: 를 생략하여 사용하였습니다. (using을 했어도 nameA를 붙여도 무방합니다.) 또한, using namespace가 아니라 using 후 특정 항목만 지정해서 사용가능합니다. using std::cout 을 통해 컴파일러에게 지시를 하여 cout은 std::없이 사용했지만 endl의 경우 std::endl로 사용하였습니다. 🧨 웬만하면 using 지시자는 사용하지 않는 방향으로 개발하시는 것이 좋습니다. (using namespace std 포함) - 예상치 못한 변수나 함수명이 겹치는 경우가 발생할 수 있기 때문입니다. ref) https://en.cppreference.com/w/cpp/language/namespace","link":"/2021/06/07/cpp_namespace/"},{"title":"2017 팁스타운 - 예상 대진표","text":"[문제 원본] https://programmers.co.kr/learn/courses/30/lessons/12985 간단한 규칙 찾기 및 구현 문제입니다. A 참가자와 B 참가자가 토너먼트에 참가했을때, 만나게 되는 round의 값을 리턴해주면 되는 문제입니다. 이겼을 때 다음 번호의 규칙성을 파악하면 쉽게 풀립니다. 1번의 참가자가 이겼을 경우) 다음 번호는 1번 4번의 참가자가 이겼을 경우) 다음 번호는 2번 3번의 참가자가 이겼을 경우) 다음 번호는 2번 15번의 참가자가 이겼을 경우) 다음 번호는 8번 16번의 참가자가 이겼을 경우) 다음 번호는 8번 -&gt; 나누기 2를 한 다음 올림을 하는 규칙임을 파악할 수 있습니다.loop를 돌면서 a, b가 같은 번호일 때의 round를 return 하면 됩니다. 12345678910#include &lt;iostream&gt;int solution(int n, int a, int b) { for (int round = 1; round &lt; 20; round++) { a = a / 2 + a % 2; b = b / 2 + b % 2; if (a == b) return round; }}","link":"/2021/06/13/2017TIPSTown-1/"},{"title":"2017 팁스타운 - 짝지어 제거하기","text":"[문제 원본]코딩테스트 연습 - 짝지어 제거하기 | 프로그래머스 (programmers.co.kr)괄호 문제, 짝 짓는 문제 등은 보통 Stack으로 풀릴 때가 많습니다. 같은 문자가 반복되는 짝을 계속하여 제거하였을 때, 모두 제거가 되는지 판단하는 문제입니다.아래와 같은 논리로 접근하시면 됩니다. 문자열이 홀수인 경우 모두 짝을 지어도 1개는 꼭 남기때문에 바로 0을 return 짝을 판단할 Stack 생성 (STL의 stack 컨테이너 사용) 문자열의 처음부터 진행하여 stack이 비었을 경우 현재 문자를 pushstack이 비어있지 않은 경우 stack의 top과 비교하였을 때 일치하면 pop으로 제거 일치하지 않으면 push로 담기 문자열의 길이만큼 Iteration 후 stack이 비어있는지 return하면 됩니다. 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;int solution(string s) { if(s.size()%2) return 0; stack&lt;char&gt; st; for(auto it = s.begin(); it != s.end(); ++it) { if(st.empty() || st.top()!=*it) st.push(*it); else st.pop(); } return st.empty();}","link":"/2021/06/14/2017TIPSTown-2/"},{"title":"Ubuntu Exfat","text":"터미널을 열어 아래 명령어를 입력합니다. 1sudo apt install exfat-fuse exfat-utils 끝","link":"/2021/06/14/ubuntu-exfat/"}],"tags":[],"categories":[{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Programming Languages","slug":"Development/Programming-Languages","link":"/categories/Development/Programming-Languages/"},{"name":"C++","slug":"Development/Programming-Languages/C","link":"/categories/Development/Programming-Languages/C/"},{"name":"Algorithm","slug":"Development/Algorithm","link":"/categories/Development/Algorithm/"},{"name":"프로그래머스","slug":"Development/Algorithm/프로그래머스","link":"/categories/Development/Algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"OS","slug":"Development/OS","link":"/categories/Development/OS/"},{"name":"Ubuntu","slug":"Development/OS/Ubuntu","link":"/categories/Development/OS/Ubuntu/"}]}